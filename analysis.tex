\chapter{Tool analysis}
\label{cha:analysis}

In this chapter we will discuss the state-of-the-art tool developed by the jointly work of University of Trento and D-Wave. More specifically we will emphasise critical points of the current version, suggesting possible direction to improve the performance of the algorithm.

\section{The issue of co-tunnelling}

The major issue while converting a SAT problem into a Ising instance is represented by the problem known as \textbf{co-tunneling}. Co-tunneling is a side-effect issue caused by the presence of long chains of qubits in the annealer's placement \cite{cotunneling}. [Discuss cotunneling in more details]

\section{Studying the Ising encoding}

To determine the behaviour of the placement algorithm and to easily understand how frequently long chains are generated, it was required to graphically represent the annealer architecture when applied to a SAT-to-Ising encoding task. \\
A new script has been developed to accomplish this task, called \textit{graph\_to\_dot}. The first step was the building of a graph reflecting the architecture of the quantum annealer chosen at execution. Information about the topology of the network has been retrieved using \textbf{D-Wave NetworkX}, an extension of NetworkX providing tools and data for working with the D-Wave systems \cite{dwavenetx}. Data about the has been collected from the \textit{place\_and\_route} algorithm: for each AIG-related subformula the algorithm returns a subset of qubits to the graph and the values of weights extracted from the pre-computed libraries. Using this information, we choose a color for each penalty function and use it to determine the related qubits and the involved couplings in the graphical representation. The color of edges representing chains of a Boolean variable have been set to black. 
An example of Boolean formula placement is shown in figure xx.

\begin{figure}[]
	\begin{center}
	\includegraphics[width=0.8\textwidth]{images/graph7.png}
	\caption{A graphical representation of the encoding of a benchmark problem, C17, into the Pegasus architecture.}
	\end{center}
\end{figure}

The major issue visible from the figure is the presence of long chains of qubits. As already stated in paragraph 3.1, higher size of chains worsen the stability of the annealers in the search of the Hamiltonian final state. Each qubit belonging to the chain can be potentially more useful: unused arcs adjacent to them and set to 0 could be used to determine novel penalty functions. The results would be more complex structures that could help us in obtaining better penalty function, less prone to be subject to co-tunelling and with higher $gap_{min}$.
The script was integrated to the original code as a debug option, permitting other users to test their encoding and better understanding the results behind the implemented procedures.

\section{The searchPF function}

The previous section suggested the idea to recompute penalties function reducing the length of the chains. These nodes, used as ancillas and considering their unused couplings, could provide more complex encoding, reducing the co-tunneling effect and guaranteeing more energy stability. The tool already provide a class of algorithms to compute offset, biases and couplings of an Ising problem, given a topology and the Boolean function. Each function provided some specific constraints in order to satisfying properties such as getting the maximum $g_{min}$  The function relevant to the scope of this thesis, called \textbf{searchPF}, was the most suitable to our purpose, given its simplicity and its ease to be extended. \\
\textit{SearchPf} requires as input the following objects:

\begin{itemize}
    \item A graph representing the topology of the involved qubits. Graphs are created using the \textit{GraphViz} library, setting the nodes name as the integer in the range [1,$N$] with N the number of qubits.
    \item A function representing the Booolean formula we desire to map into the given graph.
    \item Two integers $nx$ ans $na$, representing respectively the number of qubits representing the variables and the number of qubits working as ancillas.
\end{itemize}

In order to get the weights defining the penalty function, an Optimization Satisfiability problem is instantiated using the previously mentioned parameters. The problem is fed to OptiMathSAT, which returns in response an empty if no valid penalty functions has been found; otherwise, a dictionary containing the parameters value and the minimum gap is returned. Multiple constraints are set to map the problem into the SMT-LIB language:
 
\begin{itemize}
    \item \textbf{Architecture constraints}: we ensure the resulting penalty function respects the topology of the given graph. As a consequence, some couplings need to be set to 0 a.
    \item \textbf{Range constraints}: As stated in section 1.5, values of biases and couplings need to be constrained so that they cannot violate their ranges. For each coupling and each bias an assert condition setting lower an upper bounds are added to the OMT encoding.
    \item \textbf{Expansion gap constraints}: in order to retrieve the parameters of the Ising function we have to solve the  quantified OMT problem described in 
\end{itemize}

The function has been heavily tested to learn its behaviour, its complexity and thus offering cues for improvements. First we studied the relation between the required time to obtain a solution to the OMT problem and the number involved variables, with the goal of determining an upper bound for the number of nodes so that the OMT problems can return their solution in a feasible amount of time to be applied in real-life applications. Table 3.1 shows the results of this analysis; we can see how we are bound to use a very low number of qubits.
\begin{table}[]
\centering
\begin{tabular}{|c|c|}
\hline
\rowcolor[HTML]{FFCC67} 
N. of qubits & Running time \\ \hline
7            & 1.49 s       \\ \hline
8            & 1.93 s       \\ \hline
9            & 5.01 s       \\ \hline
10           & 33,4 s       \\ \hline
11           & $>$ 180 s      \\ \hline
\end{tabular}
\caption{A table showing the time required to retrieve the penalty function of $A = B \wedge C$ with an increasing number of variables, most of them used as ancillas.}
\label{tab:my-table}
\end{table}
This is not surprising: solving equation xx requires. More details will be provided in the conclusive chapter, suggesting future approaches to overcome this limit. \\
We additionally implemented a small section of code to write the output of the procedure on a TXT file, giving us the opportunity to easily understand how \textit{searchPf} generates the problem and its inefficiencies. Some aspect have jumped to our eyes:

\begin{itemize}
    \item The number of coupling variables generated by the script were higher than the required ones. The architecture constraints tend to create a weight of each pair of qubits, then when the connection is not reflected in the topology of the graph its value is set to 0. While the correctness of the solution is achieved by this approach, an higher number of decision variables lengthens the time to get the solution.
    \item When an instance is fed to the OMT solver, it tends to return solutions where the connections among ancillas get -1 as value. This result is in contradiction with our goal; most of these parameters should have a value different from -1 not to be part of the chain.
\end{itemize}

\pagebreak

