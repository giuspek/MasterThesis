\chapter{From CP to OMT}
\label{cha:OMTcore}

\section{The first interface: FZN2OMT}

The first tentative to implement a CP-to-OMT converter is represented by FZN2OMT, developed by Patrick Trentin at the University of Trento and heavily discussed in \cite{cp2omt}. The interface, written in Python, managed the majority of issues raised in chapter 1.5 and is capable of translating a good variety of MiniZinc/FlatZinc problems. The compiler was developed in order to test the performance of OptiMathSAT in solving CP problems, which was an almost unexplored field. Results showed how OMT solvers are usually penalized by the absence of procedures for global constraints and the management of Pseudo-Boolean constraints with respect to MiniZinc, offering cues for further studies and improvements. The main issue behind this solver is its dependence from MathSAT: as already stated, OptiMathSAT is built on top of the SMT solver and, since it is proprietary code, the code cannot be distributed as open-source code. This condition prevents other computer scientists to easily test the bridge between the two paradigms and slows down the search of OptiMathSAT critical points to fix. As a consequence, the first goal we decided to pose was the independence from the SMT solver and the release of the code under the GNU General Public License v. 3.0 \cite{GPL}. \\
Once accomplish this first essential task, it was interesting to extend this primitive interface introducing new updates, most of them generated by MathSAT and OptiMathSAT evolution in the last years. Some arithmetics are currently not considered in the translation, in particular the Bit-Vector representation (when expressly stated, Bit Vector variable are simply translated into SMT Integer variables). 

\section{Open-source FZN2OMT}

In the next paragraphs we will discuss the workflow and the design choices adopted to build the open-source version of the FZN2OMT. The first part will cover the development of an equivalent version of the previous FZN2OMT, while improvements and extensions to the original tool will discussed in the second section.

\subsection{Designing the skeleton}

In order to develop a standalone version of the interface satisfying the requirements underlined in 3.1, it was necessary to modify the majority of data structures and algorithms. The goal was to remove, when possible, procedures and structures which were useless for the tasks we wanted to integrate; the remaining cases required huge modifies to simplify their behaviour and step away from their original encoding. Lastly, all dependencies from the SMT solver had to be removed to avoid legal issues. \\
As a first step, we took the OptiMathSAT code and manually analyzed its structure to define the MathSAT dependencies that were useless for the paradigm conversion task. In particular, all references to algorithms dealing with the search of a valid solution and the definition were outside the scope of the project and promptly removed. Not all MathSAT libraries could be entirely removed from the project without impacting the execution of the code: the OMT and the SMT solvers share some data structures essential to efficiently build an SMT-LIB encoding. To ensure the possibility to license the new tool under GPL, all these structures and the methods calling them had to be re-written from scratches. In the beginning we were simply interested in making sure no link with the SMT solver were present in the final release: as a result, we built dummy classes with attributes and empty methods inspired by MathSAT files. \\
At the end of this process, we obtained an executable interface with no dependency from the SMT solver developed by UniTN and capable of scanning the input file, even though no translation is returned.
It is important to point out how the FlatZinc language parser was part of OptiMathSAT source code and it was not required to rewrite it nor modify its code.

\subsection{Storing variables and constants}

The skeleton built in chapter 3.2.1 represents the starting point to define a working interface, satisfying the requirements previously described and accepting all the FlatZinc problems managed by the old compiler. \\
The first aspect we concentrated on was the definition of classes for variables declared in the FlatZinc Language file. Since each variable can be associated to different data types, we first added a class to efficiently store information about the type, \textbf{DataType}; this information will help us in further manipulations and simplifications, as we will deepen later. A DataType is simply defined by a unique identifier and the name we assign to the represented type, such as Int or Real. Since the solvers do not admit user-defined types, we added an initialization procedure to create the relevant data types before we parse the CP file. \\
The next step was the definition of a class to store information about frequently used symbols, such as equality and addition; we named this class \textbf{Symbol}. This class does not differ too much the previous class: in addition to the name and the identifier we also associate its type using an instance of the DataType class.\\
Each variable is embedded in a class representing the basic unit of a formula, called \textbf{Term}. For the sake of simplicity, we designed this class reducing to the bone its body:

\begin{itemize}
    \item To identify and distinguish variables, we use the already mentioned combination of ID + name.
    \item To store its type we declare a Symbol with name identical to the one provided for the variable, that will also store the type thanks to its DataType attribute.
    \item Lastly, we introduced a vector of Term called \textit{children}. When creating variables, this attribute remains empty. Its importance will be cleared when discussing the creation of constraints.
\end{itemize}

The definition of constants is identical to the procedure for decision variable, with an additional step to link the symbol with its value. This association was managed creating an unordered map using the name as key and the assigned parameter as value. \\
All these newly created instances were collected defining a container class, \textbf{TermManager}.
A brief graph summing up the hierarchy of classes and their role in the program is shown in figure xx. 

\subsection{Introducing basic behaviour}

The fundamental task that the interface is required to satisfy is the encoding of FlatZinc constraints into SMT-LIB equivalent assertions. Some of these constraints (the MiniZinc manual calls them \textbf{FlatZinc builtins}) define simple relations among variables; the other constraints, \textit{global constraints}, represent high-level modelling abstractions, for which many solvers implement special, efficient inference algorithms and require more complex encoding. Each constraint is managed with the 

\subsection{Extending FZN2OMT}

Once the essential behaviours were implemented, we decided to extend the project adding that would increase its popularity and its usage.\\
First of all, OptiMathSAT is only one of the list of the OMT solvers available to the final users. Other popular solvers are z3 \cite{z3prover} and Barcelogic \cite{barcelogic}, each one with their strengths and weaknesses. All these solvers support the SMT-LIB standard, but the format accepted by each tool presents some minor differences with respect to the others. Even though the community is currently working in removing these differences and provide a unified format to simply test a single instance of a problem in multiple tools, at the moment we need to adapt the SMT-LIB encoding to satisfy the semantic of each solver. Some of the most evident differences involve:

\begin{itemize}
    \item The setting of the background theory to exploit for a problem: since the SMT-LIB admits, for each tool we have to make sure a supported logic is passed, otherwise an error will be returned an the execution aborted. 
    \item The definition of the objective functions: each solver has different format to define the direction of the optimization and the cost function we are interested in optimizing.
\end{itemize}

Once read the manual guide for all these solvers and uniquely determined the differences that would cause an error, the best strategy that emerged to accomplish the task was the update of ----. The choice of the output solver is done when executing FZN2OMT: a command-line parameter has been added where the user can change the default output solver (OptiMathSAT) with the other tools named at the beginning of this section. \\
The second extension proposed to the interface involves the Bit-Vector arithmetic. At the current state, FZN2OMT does not provide support for Bit-Vector encoding and Integer value cannot be mapped to an equivalent finite-precision encoding. On the other hand, huge progresses has been made in the definition of algorithms to efficiently search solutions for this theory, so testing this arithmetic would be of interest for the field Optimization Modulo Theories. SMT-LIB defines a different syntax for Bit-Vector variables and operations, requiring a modification .  

\newpage
